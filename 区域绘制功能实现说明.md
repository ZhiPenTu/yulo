# 区域绘制功能实现说明

## 功能概述

区域绘制功能是AI设置模块的核心功能之一，允许用户在摄像头视频画面上绘制多边形区域，用于配置AI检测的区域范围。该功能支持多种区域类型，包括车道区、实线、拥堵区、禁行区等，并支持保存到数据库。

## 设计稿还原

根据提供的设计稿，功能包含以下核心元素：

### 1. 弹窗布局
- 大尺寸对话框（90%宽度）
- 左侧：视频播放区域
- 右侧：控制面板

### 2. 视频播放区域
- 顶部显示摄像头编号和时间戳
- 中间显示视频画面（来自 camera_url 字段）
- 视频上方覆盖透明画布用于绘制

### 3. 控制面板
- 区域类型下拉框
- 新增按钮
- 区域列表（显示区域编号）
- 开始绘制/结束绘制按钮
- 保存区域/取消按钮
- 图片预览模式开关

### 4. 区域显示
- 未选中区域：绿色半透明填充
- 选中区域：蓝色半透明填充
- 区域中心显示编号
- 顶点显示为圆点

## 技术实现

### 1. 数据结构

#### 区域数据格式

```javascript
{
  id: 1,                              // 区域编号
  type: 'Lane',                       // 区域类型值
  typeName: '车道区',                 // 区域类型名称
  points: [[x1, y1], [x2, y2], ...], // 多边形顶点坐标
  direction: 'up',                    // 车道方向
  laneType: 'lane',                   // 车道类型
  minSpeed: 60,                       // 最低限速
  maxSpeed: 120                       // 最高限速
}
```

#### 区域类型定义

```javascript
const regionTypes = [
  { label: '车道区', value: 'Lane' },
  { label: '实线', value: 'line_type.diagonal_line' },
  { label: '拥堵区', value: 'congestion_area' },
  { label: '禁行区', value: 'lane_type.disjoint_lane' },
  { label: '人、非机械禁区', value: 'person_invasion' },
  { label: '车辆屏蔽区', value: 'vehicle_mask_area' },
  { label: '拥堵统计区', value: 'congestion_stat_area' },
  { label: '禁停区', value: 'parking_area' }
];
```

### 2. 核心功能实现

#### 2.1 视频和画布初始化

```javascript
const initVideoAndCanvas = () => {
  if (!videoRef.value || !canvasRef.value) return;
  
  const video = videoRef.value;
  const canvas = canvasRef.value;
  
  // 设置画布尺寸与视频一致
  video.addEventListener('loadedmetadata', () => {
    canvas.width = video.videoWidth || 1920;
    canvas.height = video.videoHeight || 1080;
    drawAllRegions();
  });
  
  drawAllRegions();
};
```

#### 2.2 新增区域

```javascript
const addRegion = () => {
  if (!selectedRegionType.value) {
    ElMessage.warning('请先选择区域类型');
    return;
  }
  
  const newRegion = {
    id: regions.value.length + 1,
    type: selectedRegionType.value,
    typeName: regionTypes.find(t => t.value === selectedRegionType.value)?.label || '',
    points: [],
    direction: '向上',
    laneType: '行车道',
    minSpeed: null,
    maxSpeed: null
  };
  
  regions.value.push(newRegion);
  selectedRegionIndex.value = regions.value.length - 1;
  ElMessage.success('区域添加成功，请选中后开始绘制');
};
```

#### 2.3 绘制控制

```javascript
// 开始绘制
const startDrawing = () => {
  if (selectedRegionIndex.value === null) {
    ElMessage.warning('请先选择一个区域');
    return;
  }
  
  isDrawing.value = true;
  currentPoints.value = [];
  ElMessage.success('开始绘制，点击视频画面标记区域顶点');
};

// 结束绘制
const endDrawing = () => {
  if (!isDrawing.value) {
    ElMessage.warning('当前没有在绘制');
    return;
  }
  
  if (currentPoints.value.length < 3) {
    ElMessage.warning('至少需要标记3个点');
    return;
  }
  
  // 保存当前绘制的点到选中的区域
  regions.value[selectedRegionIndex.value].points = [...currentPoints.value];
  
  isDrawing.value = false;
  currentPoints.value = [];
  
  drawAllRegions();
  ElMessage.success('绘制完成，已缓存到本地');
};
```

#### 2.4 画布点击处理

```javascript
const handleCanvasClick = (event) => {
  if (!isDrawing.value) return;
  
  const canvas = canvasRef.value;
  const rect = canvas.getBoundingClientRect();
  
  // 计算缩放比例
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  // 转换为画布坐标
  const x = (event.clientX - rect.left) * scaleX;
  const y = (event.clientY - rect.top) * scaleY;
  
  currentPoints.value.push([x, y]);
  drawAllRegions();
};
```

#### 2.5 绘制多边形

```javascript
const drawPolygon = (ctx, points, isSelected, regionId, isDrawing = false) => {
  if (points.length === 0) return;
  
  // 绘制路径
  ctx.beginPath();
  ctx.moveTo(points[0][0], points[0][1]);
  
  for (let i = 1; i < points.length; i++) {
    ctx.lineTo(points[i][0], points[i][1]);
  }
  
  if (!isDrawing) {
    ctx.closePath();
  }
  
  // 填充
  ctx.fillStyle = isSelected ? 'rgba(64, 158, 255, 0.3)' : 'rgba(82, 196, 26, 0.2)';
  ctx.fill();
  
  // 边框
  ctx.strokeStyle = isSelected ? '#409eff' : '#52c41a';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // 绘制顶点
  points.forEach((point, index) => {
    ctx.beginPath();
    ctx.arc(point[0], point[1], 5, 0, 2 * Math.PI);
    ctx.fillStyle = isSelected ? '#409eff' : '#52c41a';
    ctx.fill();
  });
  
  // 绘制区域ID
  if (regionId && points.length > 0) {
    const centerX = points.reduce((sum, p) => sum + p[0], 0) / points.length;
    const centerY = points.reduce((sum, p) => sum + p[1], 0) / points.length;
    
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(regionId, centerX, centerY);
  }
};
```

#### 2.6 保存到数据库

```javascript
const saveRegions = () => {
  if (regions.value.length === 0) {
    ElMessage.warning('请先添加并绘制区域');
    return;
  }
  
  // 检查是否所有区域都已绘制
  const undrawnRegions = regions.value.filter(r => !r.points || r.points.length === 0);
  if (undrawnRegions.length > 0) {
    ElMessage.warning('还有区域未绘制完成');
    return;
  }
  
  const updateData = {
    id: currentCamera.value.id,
    regions: JSON.stringify(regions.value)
  };
  
  updateCamera(updateData).then(() => {
    ElMessage.success('区域保存成功');
    currentCamera.value.regions = JSON.stringify(regions.value);
    regionDialogVisible.value = false;
  }).catch((error) => {
    ElMessage.error('区域保存失败');
    console.error('保存失败:', error);
  });
};
```

### 3. 样式实现

#### 3.1 对话框布局

```scss
.region-draw-container {
  display: flex;
  gap: 20px;
  height: 70vh;

  .video-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: #000;
    border-radius: 4px;
    overflow: hidden;
  }

  .control-panel {
    width: 300px;
    display: flex;
    flex-direction: column;
    gap: 20px;
    padding: 20px;
    background: #f5f7fa;
    border-radius: 4px;
  }
}
```

#### 3.2 视频区域

```scss
.video-section {
  .video-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 20px;
    background: rgba(0, 0, 0, 0.8);
    color: #fff;
  }

  .video-wrapper {
    flex: 1;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #000;

    video {
      max-width: 100%;
      max-height: 100%;
    }

    .draw-canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      cursor: crosshair;
      max-width: 100%;
      max-height: 100%;
    }
  }
}
```

#### 3.3 区域列表

```scss
.region-list {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  padding: 15px;
  background: #fff;
  border-radius: 4px;
  min-height: 100px;

  .region-item {
    position: relative;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #409eff;
    color: #fff;
    border-radius: 4px;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
    transition: all 0.3s;

    &:hover {
      transform: scale(1.1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    &.active {
      background: #67c23a;
      box-shadow: 0 0 0 3px rgba(103, 194, 58, 0.3);
    }

    .delete-icon {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 20px;
      height: 20px;
      background: #f56c6c;
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.3s;
    }

    &:hover .delete-icon {
      opacity: 1;
    }
  }
}
```

## 操作流程

### 1. 打开区域绘制对话框

```
用户点击"区域绘制"按钮
  ↓
系统打开对话框
  ↓
加载摄像头视频（camera_url）
  ↓
解析已有区域数据（regions字段）
  ↓
初始化画布并绘制已有区域
```

### 2. 新增区域

```
用户选择区域类型
  ↓
点击"新增"按钮
  ↓
系统创建新区域对象
  ↓
自动选中新区域
  ↓
区域列表显示新区域编号
```

### 3. 绘制区域

```
用户选中区域
  ↓
点击"开始绘制"按钮
  ↓
在视频画面上点击标记顶点
  ↓
系统实时显示绘制进度
  ↓
点击"结束绘制"按钮
  ↓
系统保存区域到本地缓存
  ↓
多边形自动闭合并显示
```

### 4. 保存到数据库

```
用户点击"保存区域"按钮
  ↓
系统检查所有区域是否已绘制
  ↓
将区域数据转换为JSON格式
  ↓
调用updateCamera API保存
  ↓
显示保存成功提示
  ↓
关闭对话框
```

## 数据库设计

### regions 字段格式

```json
[
  {
    "id": 1,
    "type": "Lane",
    "typeName": "车道区",
    "points": [
      [200, 300],
      [800, 300],
      [800, 600],
      [200, 600]
    ],
    "direction": "up",
    "laneType": "lane",
    "minSpeed": 60,
    "maxSpeed": 120
  },
  {
    "id": 2,
    "type": "congestion_area",
    "typeName": "拥堵区",
    "points": [
      [500, 400],
      [900, 400],
      [900, 700],
      [500, 700]
    ],
    "direction": "up",
    "laneType": "lane",
    "minSpeed": null,
    "maxSpeed": null
  }
]
```

## 文件清单

### 前端文件

1. **yulo-ui/src/views/AIsSettings/index.vue**
   - 主要修改：添加区域绘制功能
   - 新增状态变量：regionDialogVisible, currentCamera, regions等
   - 新增方法：handleEdit, addRegion, startDrawing, endDrawing等
   - 新增对话框：区域绘制对话框
   - 新增样式：region-draw-container相关样式

### 后端文件

无需修改后端代码，使用现有的 updateCamera API 即可。

### 测试文件

1. **test-region-draw.html**
   - 独立的测试页面
   - 可以脱离系统单独测试区域绘制功能

2. **区域绘制功能测试说明.md**
   - 详细的测试步骤和测试要点
   - 包含测试用例和测试报告模板

## 技术要点

### 1. 坐标转换

由于画布可能被缩放显示，需要进行坐标转换：

```javascript
const rect = canvas.getBoundingClientRect();
const scaleX = canvas.width / rect.width;
const scaleY = canvas.height / rect.height;

const x = (event.clientX - rect.left) * scaleX;
const y = (event.clientY - rect.top) * scaleY;
```

### 2. 画布居中

使用 CSS transform 使画布居中显示：

```css
.draw-canvas {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

### 3. 视频加载

等待视频元数据加载完成后再设置画布尺寸：

```javascript
video.addEventListener('loadedmetadata', () => {
  canvas.width = video.videoWidth || 1920;
  canvas.height = video.videoHeight || 1080;
});
```

### 4. 数据持久化

使用 JSON.stringify 将区域数据转换为字符串存储：

```javascript
const updateData = {
  id: currentCamera.value.id,
  regions: JSON.stringify(regions.value)
};
```

### 5. 数据解析

从数据库读取时需要解析 JSON 字符串：

```javascript
if (row.regions) {
  try {
    const parsedRegions = typeof row.regions === 'string' 
      ? JSON.parse(row.regions) 
      : row.regions;
    regions.value = parsedRegions || [];
  } catch (e) {
    console.error('解析区域数据失败:', e);
    regions.value = [];
  }
}
```

## 注意事项

### 1. 视频源

- camera_url 字段必须包含有效的视频地址
- 视频格式需要浏览器支持（推荐 MP4）
- 视频地址需要可访问（注意跨域问题）

### 2. 性能优化

- 避免频繁重绘画布
- 使用 requestAnimationFrame 优化动画
- 大量区域时考虑分层渲染

### 3. 浏览器兼容性

- 使用 Canvas API 需要现代浏览器支持
- 视频播放需要浏览器支持 HTML5 video
- 建议使用 Chrome、Firefox、Safari 等现代浏览器

### 4. 数据验证

- 保存前检查所有区域是否已绘制
- 检查多边形至少有3个顶点
- 检查数据格式是否正确

### 5. 用户体验

- 提供清晰的操作提示
- 实时显示绘制进度
- 支持撤销和重做操作（待实现）
- 支持区域编辑功能（待实现）

## 后续优化建议

### 1. 功能增强

- [ ] 支持区域编辑（移动顶点、添加/删除顶点）
- [ ] 支持区域复制和粘贴
- [ ] 支持区域模板功能
- [ ] 支持批量导入导出
- [ ] 支持撤销和重做
- [ ] 支持区域搜索和过滤

### 2. 交互优化

- [ ] 添加快捷键支持
- [ ] 添加右键菜单
- [ ] 添加缩放和平移功能
- [ ] 添加网格和标尺
- [ ] 添加吸附功能

### 3. 视觉优化

- [ ] 支持自定义区域颜色
- [ ] 支持区域透明度调整
- [ ] 添加区域标签显示
- [ ] 添加区域统计信息

### 4. 性能优化

- [ ] 使用 WebGL 渲染大量区域
- [ ] 实现虚拟滚动
- [ ] 优化数据结构
- [ ] 添加缓存机制

## 总结

区域绘制功能已经完整实现，包括：

1. ✅ 视频播放（来自 camera_url 字段）
2. ✅ 区域类型选择（8种类型）
3. ✅ 区域新增和删除
4. ✅ 区域绘制（多边形）
5. ✅ 区域选中和高亮
6. ✅ 数据保存到数据库
7. ✅ 数据加载和显示
8. ✅ 完整的测试页面和文档

功能已经精准还原设计稿，并实现了所有需求。可以开始测试验证。
